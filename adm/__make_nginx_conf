#!/usr/bin/env python3

import os
import glob
import envtpl
import sys
import hashlib
import copy
from configparser_extended import ExtendedConfigParser
from mflog import get_logger
from mfutil.plugins import layerapi2_label_to_plugin_name
from mfserv.plugins_common import get_unix_sockets, get_hot_swap_prefix, \
    get_plugin_format_version, get_workers
from mfserv.plugins_deprecated import test_deprecated_options, is_typ_valid

MFMODULE_RUNTIME_HOME = os.environ["MFMODULE_RUNTIME_HOME"]
MFSERV_PLUGINS_HOME = os.path.join(MFMODULE_RUNTIME_HOME,
                                   "var", "plugins")
MFSERV_PLUGINS_HOTSWAP_HOME = os.path.join(MFMODULE_RUNTIME_HOME,
                                           "tmp", "plugins.hotswap")
MFSERV_NGINX_TIMEOUT = int(os.environ['MFSERV_NGINX_TIMEOUT'])
CONFIG = os.environ.get('MFCONFIG', 'GENERIC')
HOSTNAME = os.environ.get('MFCOM_HOSTNAME')
HOSTNAME_FULL = os.environ.get('MFCOM_HOSTNAME_FULL')
MFMODULE = os.environ['MFMODULE']

# FIXME: fix to ensure compatibility with existing plugins using
# old variables names MODULE* (to be removed)
for var in ["MODULE", "MODULE_HOME", "MODULE_LOWERCASE", "MODULE_VERSION",
            "MODULE_STATUS", "MODULE_RUNTIME_HOME", "MODULE_RUNTIME_USER",
            "MODULE_RUNTIME_SUFFIX", "MODULE_PLUGINS_BASE_DIR"]:
    new_var = 'MF' + var
    if var not in os.environ and new_var in os.environ:
        os.environ[var] = os.environ[new_var]


LOGGER = get_logger("__make_nginx_conf")


def is_valid_extra_route(x):
    return x.startswith('/') and (x == '/' or not x.endswith('/'))


def get_nginx_conf_string(parser, plugin_directory, plugin_name, plugin_label,
                          section, key):
    extra_nginx_conf_string = ""
    if parser.has_option(section, key):
        extra_nginx_conf_filename = parser.get(section, key)
        if extra_nginx_conf_filename != "null":
            extra_nginx_conf_filepath = \
                os.path.join(plugin_directory,
                             extra_nginx_conf_filename)
            with open(extra_nginx_conf_filepath, "r") as f:
                extra_nginx_conf_string = f.read()
    return envtpl.render_string(
        extra_nginx_conf_string,
        # FIXME: drop PLUGIN var ?
        extra_variables={"PLUGIN": {"name": plugin_name},
                         "MFSERV_CURRENT_PLUGIN_NAME": plugin_name,
                         "MFSERV_CURRENT_PLUGIN_DIR": plugin_directory,
                         "MFSERV_CURRENT_PLUGIN_LABEL": plugin_label},
        keep_multi_blank_lines=False)


def get_conf(plugin_configuration_file, hot_swap_plugin=False):
    plugin_conf = {}
    plugin_directory = os.path.dirname(plugin_configuration_file)
    parser = ExtendedConfigParser(config=CONFIG, strict=False,
                                  inheritance='im', interpolation=None)
    try:
        with open(os.path.join(plugin_directory,
                               ".layerapi2_label"), "r") as f:
            label = f.read().strip()
    except Exception:
        LOGGER.warning(
            "can't read %s/.layerapi2_label => ignoring this plugin",
            plugin_directory)
        return None
    try:
        plugin_name = layerapi2_label_to_plugin_name(label)
    except Exception as e:
        LOGGER.warning("can't read %s/.layerapi2_label with error: %s => "
                       "ignoring this plugin", plugin_directory, e)
        return None
    logger = LOGGER.bind(plugin_name=plugin_name)
    parser.read(plugin_configuration_file)
    if parser.has_option("__advanced", "disable_nginx_conf"):
        if parser.getboolean("__advanced", "disable_nginx_conf"):
            logger.warning("disabled plugin => ignoring")
            return None
    version = get_plugin_format_version(logger, parser)
    logger = logger.bind(version=version)
    test_deprecated_options(logger, parser)
    apps = [x.replace("app_", "", 1).split(':')[0] for x in parser.sections()
            if x.startswith("app_")]

    extra_general_nginx_http_conf_string = \
        get_nginx_conf_string(parser, plugin_directory, plugin_name, label,
                              "general", "extra_nginx_http_conf_filename")
    extra_general_nginx_server_conf_string = \
        get_nginx_conf_string(parser, plugin_directory, plugin_name, label,
                              "general", "extra_nginx_server_conf_filename")
    extra_general_nginx_init_worker_by_lua_block_string = \
        get_nginx_conf_string(
            parser, plugin_directory, plugin_name, label,
            "general", "extra_nginx_init_worker_by_lua_block_filename")

    plugin_conf["name"] = plugin_name
    plugin_conf["extra_general_nginx_http_conf_string"] = \
        extra_general_nginx_http_conf_string
    plugin_conf["extra_general_nginx_server_conf_string"] = \
        extra_general_nginx_server_conf_string
    plugin_conf["extra_general_nginx_init_worker_by_lua_block_string"] = \
        extra_general_nginx_init_worker_by_lua_block_string
    plugin_conf['lua_package_paths'] = []
    plugin_conf["apps"] = []

    if len(glob.glob(os.path.join(plugin_directory, '*.lua'))) > 0:
        lua_package_path = os.path.join(plugin_directory, '?.lua')
        plugin_conf['lua_package_paths'].append(lua_package_path)

    for app in apps:
        logger = logger.bind(app=app)
        section = "app_%s" % app
        if version < 1:
            typ = parser.get(section, "type")
            if not is_typ_valid(typ):
                logger.warning("unknown typ: %s => ignoring app", typ)
                continue
        if len(glob.glob(os.path.join(plugin_directory, app, '*.lua'))) > 0:
            lua_package_path = os.path.join(plugin_directory, app, '?.lua')
            plugin_conf['lua_package_paths'].append(lua_package_path)
        extra_nginx_conf_string = \
            get_nginx_conf_string(parser, plugin_directory, plugin_name, label,
                                  section, "extra_nginx_conf_filename")
        extra_nginx_conf_static_string = \
            get_nginx_conf_string(parser, plugin_directory, plugin_name, label,
                                  section, "extra_nginx_conf_static_filename")
        static_routing = True
        if parser.has_option(section, "static_routing"):
            static_routing = parser.getboolean(section, "static_routing")
        static_url_prefix = "/static"
        if parser.has_option(section, "static_url_prefix"):
            static_url_prefix = parser.get(section, "static_url_prefix")
        static_directory = "/static"
        if parser.has_option(section, "static_directory"):
            static_directory = parser.get(section, "static_directory")

        workers = get_workers(logger, parser, section)

        debug = False
        if parser.has_option(section, "debug"):
            debug = (parser.getint(section, "debug") == 1)
        virtualdomain_based_routing = True
        if parser.has_option(section, "virtualdomain_based_routing"):
            virtualdomain_based_routing = \
                parser.getboolean(section,
                                  "virtualdomain_based_routing")
        prefix_based_routing = True
        if parser.has_option(section, "prefix_based_routing"):
            prefix_based_routing = \
                parser.getboolean(section,
                                  "prefix_based_routing")
        prefix_based_routing_extra_routes = []
        if prefix_based_routing:
            if parser.has_option(section, "prefix_based_routing_extra_routes"):
                tmp = parser.get(section, "prefix_based_routing_extra_routes")
                if tmp.strip() != "null":
                    prefix_based_routing_extra_routes = \
                        [x.strip() for x in tmp.strip().split(';')
                         if is_valid_extra_route(x)]
        workdir = os.path.join(plugin_directory, app)
        timeout = MFSERV_NGINX_TIMEOUT
        if parser.has_option(section, "timeout"):
            if parser.get(section, "timeout") != "null":
                if parser.getint(section, "timeout") > 0:
                    timeout = parser.getint(section, "timeout")
        virtualdomains = set()
        for host in (HOSTNAME, HOSTNAME_FULL, "localhost"):
            virtualdomains.add("%s.%s.%s" % (app, plugin_name, host))
            if app == "main" or len(apps) == 1:
                virtualdomains.add("%s.%s" % (plugin_name, host))
        name = "app_%s_%s" % (plugin_name, app)
        if debug:
            workers = 1
        app_conf = {"name": name,
                    "alias": "no",
                    "debug": debug,
                    "app_name": app,
                    "workers": workers,
                    "plugin_name": plugin_name,
                    "hash": hashlib.md5(name.encode('utf8')).hexdigest(),
                    "virtualdomain_based_routing": virtualdomain_based_routing,
                    "prefix_based_routing": prefix_based_routing,
                    "prefix": "/%s/%s" % (plugin_name, app),
                    "virtualdomains": sorted(list(virtualdomains)),
                    "workdir": workdir,
                    "timeout": timeout + 2,  # kill the backend first
                    "static_routing": static_routing,
                    "static_directory": static_directory,
                    "static_url_prefix": static_url_prefix,
                    "hot_swap_prefix": get_hot_swap_prefix(hot_swap_plugin)}
        app_conf["sockets"] = \
            get_unix_sockets(plugin_name, app, workers,
                             app_conf["hot_swap_prefix"])
        app_conf['extra_nginx_conf_string'] = \
            envtpl.render_string(extra_nginx_conf_string,
                                 extra_variables={"APP": app_conf},
                                 keep_multi_blank_lines=False)
        app_conf['extra_nginx_conf_static_string'] = \
            envtpl.render_string(extra_nginx_conf_static_string,
                                 extra_variables={"APP": app_conf},
                                 keep_multi_blank_lines=False)
        plugin_conf["apps"].append(app_conf)
        if app == "main" or len(apps) == 1:
            copy_conf = copy.deepcopy(app_conf)
            copy_conf['prefix'] = "/%s" % plugin_name
            copy_conf['alias'] = "yes"
            plugin_conf["apps"].append(copy_conf)
        for extra_route in prefix_based_routing_extra_routes:
            copy_conf = copy.deepcopy(app_conf)
            copy_conf['prefix'] = extra_route
            copy_conf['alias'] = "yes"
            plugin_conf["apps"].append(copy_conf)
    return plugin_conf


plugins = []
lua_package_paths = []
if len(sys.argv) == 2:
    config_files = glob.glob(sys.argv[1] + "/config.ini")
    config_files2 = []
else:
    config_files1 = glob.glob(MFSERV_PLUGINS_HOME + "/*/config.ini")
    config_files2 = glob.glob(MFSERV_PLUGINS_HOTSWAP_HOME + "/*/config.ini")
    config_files = config_files1 + config_files2
for config_file in config_files:
    plugin_conf = get_conf(config_file,
                           hot_swap_plugin=(config_file in config_files2))
    if plugin_conf:
        lua_package_paths = lua_package_paths + \
            plugin_conf['lua_package_paths']
        plugins.append(plugin_conf)
lua_package_paths = \
    lua_package_paths + ["%s/config/?.lua" % os.environ['MFSERV_HOME'],
                         "%s/lib/?.lua" % os.environ['MFSERV_HOME']]

nginx_conf_file = os.path.join(os.environ['MFMODULE_HOME'], 'config',
                               'nginx.conf')

with open(nginx_conf_file, "r") as f:
    mfmodule_env = sorted(
        [x for x in os.environ.keys()
         if x.startswith(MFMODULE + "_") or x.startswith("MFMODULE_")]
    )
    extra_variables = {
        "PLUGINS": plugins,
        "LUA_PACKAGE_PATH": ";".join(lua_package_paths) + ";;",
        "MFMODULE_ENVIRONMENT": mfmodule_env
    }
    content = envtpl.render_string(f.read(), extra_variables=extra_variables,
                                   keep_multi_blank_lines=False)

print(content)
